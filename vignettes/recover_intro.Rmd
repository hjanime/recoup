<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Introduction to recover package}
-->

Genomic coverages remastered! The recover package.
==================================================

The explosion of the usage of Next Generation Sequencing techniques during the 
past few years due to the seemingly endless portfolio of applications has 
created the need for new NGS data analytics tools which are able to offer 
comprehensive and at the same time flexible visualizations under several 
experimental settings and factors. An established visualization tool in NGS
experiments is the visualization of the signal created by short reads after the
application of every NGS protocol. Genome Browser (e.g. the UCSC Genome Browser)
serve very well this purpose considering single genomic areas. They are very 
good when it comes to the visualization of the abundance of a single or a few
genes or the strength of a few protein-DNA interaction sites. However, when it
comes to the visualization of average signal profiles over multiple genomic 
locations (gene regions or others like DNA methylation sites or transcription
factor binding sites), Genome Browsers fail to depict such information in a 
comprehensive way. Furthermore, they cannot visualize average signal profiles of
factored data, for example a set of genes categorized in high, medium and low
expression or even by strand and they cannot visualize all signals of interest
mapped on all the genomic regions of interest in a compact way, something that
can be done using for example a heatmap.

In such cases, bioinformaticians use several toolkits like BEDTools and 
facilities from R/Bioconductor to read/import short reads and overlap them with 
genomic regions of interest, summarize them by binning/averaging overlaps to 
control the resolution of final graphics etc. This procedure often requires the
usage of multiple tools and custom scripts with multiple steps. One of the most
comprehensive and easy-to-use tools up to date is [ngs.plot] 
(https://github.com/shenlab-sinai/ngsplot). It is sufficiently fast for most
applications and has a low memory footprint which allows users to run it in 
low end machines too. It is command line based and users can run it by using
a simple configuration file most of the times, has a rich database of genome
annotation and genomic features and uses R/Bioconductor for underlying 
calculations and plotting of profiles. However, ngs.plot is not up to date with 
modern R graphics systems like ggplot2 and ComplexHeatmap. As a result, among
others, it is impossible to create faceted genomic profiles using a statistical
design and in such cases, a lot of additional manual work and computational
time is required in order to reach the desired outcomes. The same applies to 
heatmap profiles. Furthermore, the resolution of genomic profiles (e.g. per
base coverage or per bin of base-pairs coverage) cannot be controlled and this
can cause problems in cases where extreme levels of resolution (e.g. DNAse-Seq
experiments) is required to reach meaningful biological conclusions. Last but 
not least, ngs.plot requires a not so straightforward setup in order to run, 
it does not run in a unified environment (e.g. R environment) and in some cases
produces oversized and complex output.

The recover package comes to fill such gaps by stepping on the shoulder of 
giants. It uses the now standardized and stable Bioconductor facilities to read
and import short reads from BAM/BED files and also modern R graphics systems,
namely [ggplot2](http://ggplot2.org/) and [ComplexHeatmap] 
(https://github.com/jokergoo/ComplexHeatmap) in order to create comprehensive
averaged genomic profiles and genomic profile heatmaps. In addition it offers a
lot of (easy to use) customization options and automation at various levels.
Inexperienced users can gather their data in a simple text file and just choose
one of the supported organisms and recover does the rest for them. More 
experienced users can play with several options and provide more flexible input
so as to produce optimal results. This vignette, although it covers basic usage
of the package, it offers tha basis for more sophisticated usage. recover is not
as fast as ngs.plot but we are working on this! Also, recover is not here to 
replace other more mature packages. It is here to offer more options to users
that need more sophisticated genomic profile visualizations.


## 1 Getting started

Detailed instructions on how to run the recover genomic profile creation 
pipeline can be found under the main documentation of the package:

```{r}
library(recover)
```

```{r eval=FALSE}
library(recover)
help(recover)
```

Briefly, to run metaseqr you need:

- A text tab delimited file in a spreadsheet like format containing at least unique gene identifiers (corresponding to one of metaseqr's
supported formats, for the time being Ensembl
- A list of statistical contrasts for which you wish to check differential expression
- An internet connection so that the interactive parts of the report can be properly rendered, as the report template points to external
Content Delivery Networks (CDNs) distributing the appropriate JavaScript

Everything else (e.g. genomic regions annotation etc.) can be handled by the metaseqr pipeline. Some example data are included in the
package. See the related help pages:

```{r eval=FALSE}
help(hg18.exon.data)
help(mm9.gene.data)
```

## 2 Running the metaseqr pipeline

Running a metaseqr pipeline instance is quite straightforward. Again, see the examples in the main help page. An example and the command
window output follow:

```{r echo=TRUE, eval=TRUE}
data("mm9.gene.data",package="metaseqr")
```

```{r echo=TRUE, eval=TRUE}
head(mm9.gene.counts)
```

```{r echo=TRUE, eval=TRUE}
sample.list.mm9
```

```{r echo=TRUE, eval=TRUE}
libsize.list.mm9
```

Now, running

```{r echo=TRUE, eval=FALSE, tidy=FALSE}
result <- metaseqr(
    counts=mm9.gene.counts,
    sample.list=sample.list.mm9,
    contrast=c("e15.5_vs_P0.5","P0.5_vs_P60"),
    libsize.list=libsize.list.mm9,
    annotation="fixed",
    org="mm9",
    count.type="gene",
    normalization="edger",
    statistics="edger",
    pcut=0.05,
    fig.format=c("png","pdf"),
    export.what=c("annotation","p.value","meta.p.value","adj.meta.p.value","fold.change"),
    export.scale=c("natural","log2"),
    export.values="normalized",
    export.stats=c("mean","sd","cv"),
    export.where="~/metaseqr_test",
    restrict.cores=0.8,
    gene.filters=list(
        length=list(
            length=500
        ),
        avg.reads=list(
            average.per.bp=100,
            quantile=0.25
        ),
        expression=list(
            median=TRUE,
            mean=FALSE,
            quantile=NA,
            known=NA,
            custom=NA
        ),
        biotype=get.defaults("biotype.filter","mm9")
    ),
    out.list=TRUE
)
```

will result in the following output in the command window:

```{r echo=FALSE, eval=TRUE, message=FALSE}
result <- metaseqr(
    counts=mm9.gene.counts,
    sample.list=sample.list.mm9,
    contrast=c("e15.5_vs_P0.5","P0.5_vs_P60","e15.5_vs_P0.5_vs_P60"),
    libsize.list=libsize.list.mm9,
    annotation="fixed",
    org="mm9",
    count.type="gene",
    normalization="edger",
    statistics="edger",
    pcut=0.05,
    fig.format=c("png","pdf"),
    export.what=c("annotation","p.value","meta.p.value","adj.meta.p.value","fold.change"),
    export.scale=c("natural","log2"),
    export.values="normalized",
    export.stats=c("mean","sd","cv"),
    export.where="~/metaseqr_test",
    restrict.cores=0.8,
    gene.filters=list(
        length=list(
            length=500
        ),
        avg.reads=list(
            average.per.bp=100,
            quantile=0.25
        ),
        expression=list(
            median=TRUE,
            mean=FALSE,
            quantile=NA,
            known=NA,
            custom=NA
        ),
        biotype=get.defaults("biotype.filter","mm9")
    ),
    out.list=TRUE
)
```

To get a glimpse on the results, running:

```{r echo=TRUE, eval=FALSE}
head(result$data[["e15.5_vs_P0.5"]])
```

will produce

```{r echo=FALSE, eval=TRUE}
head(result$data[["e15.5_vs_P0.5"]])
```

Check the HTML report file created at "~/metaseqr_test".

Now, the same example but with more than one statistical selection algorithms and a different normalization:

```{r eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE}
library(metaseqr)
data("mm9.gene.data",package="metaseqr")
result <- metaseqr(
    counts=mm9.gene.counts,
    sample.list=sample.list.mm9,
    contrast=c("e15.5_vs_P0.5","P0.5_vs_P60","e15.5_vs_P0.5_vs_P60"),
    libsize.list=libsize.list.mm9,
    annotation="fixed",
    org="mm9",
    count.type="gene",
    normalization="edaseq",
    statistics=c("deseq","edger"),
    meta.p="fisher",
    pcut=0.05,
    fig.format=c("png","pdf"),
    export.what=c("annotation","p.value","meta.p.value","adj.meta.p.value","fold.change"),
    export.scale=c("natural","log2"),
    export.values="normalized",
    export.stats=c("mean","sd","cv"),
    export.where="~/metaseqr_test_2",
    restrict.cores=0.8,
    gene.filters=list(
        length=list(
            length=500
        ),
        avg.reads=list(
            average.per.bp=100,
            quantile=0.25
        ),
        expression=list(
            median=TRUE,
            mean=FALSE,
            quantile=NA,
            known=NA,
            custom=NA
        ),
        biotype=get.defaults("biotype.filter","mm9")
    ),
    out.list=TRUE
)
```

An additional example with human exon data (if you have a multiple core system, be very careful on how you are using the restrict.cores
option and generally how many cores you are using with scripts purely written in R. The analysis with exon read data can very easily
cause memory problems, so unless you have more than 64Gb of RAM available, consider setting restrict.cores to something like 0.2):

```{r eval=FALSE, tidy=FALSE}
# A full example pipeline with exon counts
data("hg18.exon.data",package="metaseqr")
metaseqr(
    counts=hg18.exon.counts,
    sample.list=list(CON=c("CON_BR1","CON_BR2"),DOX=c("DOX_BR1","DOX_BR2")),
    contrast=c("CON_vs_DOX"),
    libsize.list=list(CON_BR1=17041268,CON_BR2=23579904,DOX_BR1=16018639,DOX_BR2=26294259),
    id.col=4,
    annotation="download",
    org="hg18",
    count.type="exon",
    normalization="edaseq",
    statistics="deseq",
    pcut=0.05,
    qc.plots=c(
        "mds","biodetection","countsbio","saturation","rnacomp",
        "boxplot","gcbias","lengthbias","meandiff","meanvar",
        "deheatmap","volcano","biodist","filtered"
    ),
    fig.format=c("png","pdf"),
    export.what=c("annotation","p.value","adj.p.value","fold.change","stats","counts"),
    export.scale=c("natural","log2","log10","vst"),
    export.values=c("raw","normalized"),
    export.stats=c("mean","median","sd","mad","cv","rcv"),
    restrict.cores=0.8,
    gene.filters=list(
        length=list(
            length=500
        ),
        avg.reads=list(
            average.per.bp=100,
            quantile=0.25
        ),
        expression=list(
            median=TRUE,
            mean=FALSE
        ),
        biotype=get.defaults("biotype.filter","hg18")
    )
)
```

## 3 metaseqr components

The metaseqr package includes several functions which are responsible for running each part of the pipeline (data reading and summarization,
filtering, normalization, statistical analysis and meta-analysis and reporting). Although metaseqr is designed to run as a pipeline, where
all the parameters for each individual part can be passed in the main function, several of the individual functions can be run separately
so that the more experienced user can build custom pipelines. All the HTML help pages contain analytical documentation on how to run these
functions, their inputs and outputs and contain basic examples. For example, runnning

```{r eval=FALSE}
help(stat.edgeR)
```

will open the help page of the wrapper function over the edgeR statistical testing algorithm which contains an example of data generation,
processing, up to statistical selection.

Most of the diagnostic plots, work with simple matrices as inputs, so they can be easily used outside the main pipeline, as long as all
the necessary arguments are given. It should be noted that a report can be generated only when running the whole metaseqr pipeline and in
the current version there is no support for generating custom reports.

## 4 R session information

```{r}
sessionInfo()
```
